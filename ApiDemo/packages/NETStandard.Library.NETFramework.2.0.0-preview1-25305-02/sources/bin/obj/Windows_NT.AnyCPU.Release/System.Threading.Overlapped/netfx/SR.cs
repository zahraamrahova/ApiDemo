// Do not edit this file manually it is auto-generated during the build based on the .resx file for this project.
namespace System
{
    internal static partial class SR
    {
#pragma warning disable 0414
        private const string s_resourcesName = "FxResources.System.Threading.Overlapped.SR";
#pragma warning restore 0414

#if !DEBUGRESOURCES
        internal static string Argument_AlreadyBoundOrSyncHandle {
              get { return SR.GetResourceString("Argument_AlreadyBoundOrSyncHandle", null); }
        }
        internal static string Argument_InvalidHandle {
              get { return SR.GetResourceString("Argument_InvalidHandle", null); }
        }
        internal static string Argument_NativeOverlappedAlreadyFree {
              get { return SR.GetResourceString("Argument_NativeOverlappedAlreadyFree", null); }
        }
        internal static string Argument_NativeOverlappedWrongBoundHandle {
              get { return SR.GetResourceString("Argument_NativeOverlappedWrongBoundHandle", null); }
        }
        internal static string Argument_PreAllocatedAlreadyAllocated {
              get { return SR.GetResourceString("Argument_PreAllocatedAlreadyAllocated", null); }
        }
        internal static string InvalidOperation_NativeOverlappedReused {
              get { return SR.GetResourceString("InvalidOperation_NativeOverlappedReused", null); }
        }
#else
        internal static string Argument_AlreadyBoundOrSyncHandle {
              get { return SR.GetResourceString("Argument_AlreadyBoundOrSyncHandle", @"'handle' has already been bound to the thread pool, or was not opened for asynchronous I/O."); }
        }
        internal static string Argument_InvalidHandle {
              get { return SR.GetResourceString("Argument_InvalidHandle", @"'handle' has been disposed or is an invalid handle."); }
        }
        internal static string Argument_NativeOverlappedAlreadyFree {
              get { return SR.GetResourceString("Argument_NativeOverlappedAlreadyFree", @"'overlapped' has already been freed."); }
        }
        internal static string Argument_NativeOverlappedWrongBoundHandle {
              get { return SR.GetResourceString("Argument_NativeOverlappedWrongBoundHandle", @"'overlapped' was not allocated by this ThreadPoolBoundHandle instance."); }
        }
        internal static string Argument_PreAllocatedAlreadyAllocated {
              get { return SR.GetResourceString("Argument_PreAllocatedAlreadyAllocated", @"'preAllocated' is already in use."); }
        }
        internal static string InvalidOperation_NativeOverlappedReused {
              get { return SR.GetResourceString("InvalidOperation_NativeOverlappedReused", @"NativeOverlapped cannot be reused for multiple operations."); }
        }

#endif
        internal static Type ResourceType {
              get { return typeof(FxResources.System.Threading.Overlapped.SR); }
        }
    }
}
namespace FxResources.System.Threading.Overlapped
{
    // The type of this class is used to create the ResourceManager instance as the type name matches the name of the embedded resources file
    internal static class SR
    {
    }
}
